<!DOCTYPE html>
<html>

<head>
    <title>RTL Text Debug - Visual Bounding Box and Text Position</title>
    <style>
        @font-face {
            font-family: 'STV';
            src: url('./fonts/STV Regular.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        @font-face {
            font-family: 'STV';
            src: url('./fonts/STV Bold.ttf') format('truetype');
            font-weight: bold;
            font-style: normal;
            font-display: swap;
        }

        @font-face {
            font-family: 'STV';
            src: url('./fonts/STV Light.ttf') format('truetype');
            font-weight: 300;
            font-style: normal;
            font-display: swap;
        }

        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f5f5f5;
        }

        canvas {
            border: 1px solid #ccc;
            margin: 10px;
            background: white;
        }

        .canvas-container {
            position: relative;
        }

        .canvas-container .upper-canvas {
            pointer-events: auto;
        }

        .lower-canvas {
            z-index: 1;
        }

        .upper-canvas {
            z-index: 2;
        }

        .debug-info {
            font-family: monospace;
            background: #333;
            color: #0f0;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            white-space: pre-wrap;
        }

        .controls {
            background: white;
            padding: 15px;
            border-radius: 4px;
            margin: 10px 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        button {
            padding: 8px 16px;
            margin: 5px;
            border: none;
            background: #007bff;
            color: white;
            border-radius: 4px;
            cursor: pointer;
        }

        button:hover {
            background: #0056b3;
        }

        .text-sample {
            margin: 5px 0;
            padding: 5px;
            background: #f8f9fa;
            border-left: 3px solid #007bff;
        }
    </style>
</head>

<body>
    <h1>RTL Text Debug - Visual Bounding Box and Text Position</h1>

    <div class="controls">
        <h3>Test Cases:</h3>
        <div class="text-sample">Arabic: مرحبا بك في العالم</div>
        <div class="text-sample">Hebrew: שלום עולם</div>
        <div class="text-sample">Mixed: Hello مرحبا World</div>
        <div class="text-sample">English LTR: Hello World</div>

        <br>
        <button onclick="showRTLText()">Show RTL Arabic Text</button>
        <button onclick="showLTRText()">Show LTR English Text</button>
        <button onclick="showMixedText()">Show Mixed Text</button>
        <button onclick="showSimpleTest()">Simple Test</button>
        <button onclick="showSTVFont()">Show STV Regular</button>
        <button onclick="showSTVBold()">Show STV Bold</button>
        <button onclick="showSTVLight()">Show STV Light</button>
        <button onclick="clearCanvas()">Clear Canvas</button>
        <button onclick="toggleDebugMode()">Toggle Debug Mode</button>
        <button onclick="exportJSON()">Export JSON</button>
        <input type="file" id="jsonFile" accept=".json" style="display: none;" onchange="loadJSONFile(event)">
        <button onclick="document.getElementById('jsonFile').click()">Import JSON</button>
        <div style="margin-top:8px; display:flex; gap:6px; flex-wrap:wrap;">
            <button onclick="setAlign('left')">Align Left</button>
            <button onclick="setAlign('center')">Align Center</button>
            <button onclick="setAlign('right')">Align Right</button>
            <button onclick="setAlign('justify')">Justify</button>
            <button onclick="setAlign('justify-left')">Justify-Left</button>
            <button onclick="setAlign('justify-center')">Justify-Center</button>
            <button onclick="setAlign('justify-right')">Justify-Right</button>
        </div>
        <div style="margin-top:8px;">
            <strong>Kashida Test (Arabic Justification):</strong>
        </div>
        <div style="margin-top:4px; display:flex; gap:6px; flex-wrap:wrap;">
            <button onclick="showKashidaTest('none')" style="background:#6c757d;">Kashida: None</button>
            <button onclick="showKashidaTest('short')" style="background:#17a2b8;">Kashida: Short (25%)</button>
            <button onclick="showKashidaTest('medium')" style="background:#28a745;">Kashida: Medium (50%)</button>
            <button onclick="showKashidaTest('long')" style="background:#ffc107; color:#333;">Kashida: Long
                (75%)</button>
            <button onclick="showKashidaTest('stylistic')" style="background:#dc3545;">Kashida: Stylistic
                (100%)</button>
        </div>
        <div style="margin-top:4px; display:flex; gap:6px; flex-wrap:wrap;">
            <button onclick="setKashida('none')">Set None</button>
            <button onclick="setKashida('short')">Set Short</button>
            <button onclick="setKashida('medium')">Set Medium</button>
            <button onclick="setKashida('long')">Set Long</button>
            <button onclick="setKashida('stylistic')">Set Stylistic</button>
        </div>
    </div>

    <canvas id="canvas" width="1080" height="1080"></canvas>

    <div id="debug-info" class="debug-info">Debug information will appear here...</div>
    <div id="click-info" class="debug-info">Click on text to see selection coordinates...</div>

    <script src="./dist/index.js?v=10"></script>
    <script>
        console.log("DEBUG: Updated rtl-debug.html loaded");
        // alert("DEBUG: Updated RTL Page Loaded - Please check console for 'Hit Testing Debug' when clicking");
        // Check if fabric.js loaded
        console.log('fabric object:', typeof fabric);
        console.log('fabric.Canvas:', typeof fabric.Canvas);
        console.log('fabric.Text:', typeof fabric.Text);
        console.log('fabric.IText:', typeof fabric.IText);

        if (typeof fabric === 'undefined') {
            document.getElementById('debug-info').textContent = 'ERROR: fabric.js not loaded! Check the script path.';
        }

        const canvas = new fabric.Canvas('canvas', {
            backgroundColor: 'white',
            selection: true,
            preserveObjectStacking: true
        });

        // Ensure upper canvas is transparent
        canvas.upperCanvasEl.style.backgroundColor = 'transparent';
        let debugMode = true;
        let currentText = null;
        let debugInfo = document.getElementById('debug-info');
        let clickInfo = document.getElementById('click-info');

        // Test canvas rendering immediately
        console.log('Canvas created:', canvas);
        console.log('Canvas element:', canvas.getElement());

        // Add immediate visual test
        const testCircle = new fabric.Circle({
            left: 10,
            top: 10,
            radius: 10,
            fill: 'orange'
        });
        canvas.add(testCircle);
        canvas.renderAll();
        console.log('Test circle added, canvas should show orange dot in top-left');

        function updateDebugInfo(text, label) {
            if (!text || !debugMode) {
                debugInfo.textContent = 'Debug mode disabled or no text object';
                return;
            }

            const bbox = text.getBoundingRect();
            const info = `
${label} Debug Information:
═══════════════════════════════════════════════

Text Properties:
├─ Text: "${text.text}"
├─ Direction: ${text.direction}
├─ TextAlign: ${text.textAlign}
├─ Kashida: ${text.kashida || 'none'}
├─ enableAdvancedLayout: ${text.enableAdvancedLayout}
├─ Width: ${text.width.toFixed(2)}
├─ Height: ${text.height.toFixed(2)}
├─ Left: ${text.left.toFixed(2)}
├─ Top: ${text.top.toFixed(2)}
├─ OriginX: ${text.originX}
├─ OriginY: ${text.originY}

Bounding Box (Visual Rectangle):
├─ Left: ${bbox.left.toFixed(2)}
├─ Top: ${bbox.top.toFixed(2)} 
├─ Width: ${bbox.width.toFixed(2)}
├─ Height: ${bbox.height.toFixed(2)}
├─ Right: ${(bbox.left + bbox.width).toFixed(2)}
├─ Bottom: ${(bbox.top + bbox.height).toFixed(2)}

Internal Layout:
├─ _getLeftOffset(): ${text._getLeftOffset().toFixed(2)}
├─ _getTopOffset(): ${text._getTopOffset().toFixed(2)}
├─ Lines: ${text._textLines.length}
${text._textLines.map((line, i) => `│  └─ Line ${i}: "${line}" (length: ${line.length})`).join('\n')}

Line Left Offsets:
${text._textLines.map((line, i) => `├─ Line ${i}: ${text._getLineLeftOffset(i).toFixed(2)}`).join('\n')}

Character Bounds (first line):
${text.__charBounds && text.__charBounds[0] ?
                    text.__charBounds[0].map((char, i) =>
                        `├─ Char ${i}: left=${char.left.toFixed(2)}, width=${char.width.toFixed(2)}, kernedWidth=${char.kernedWidth.toFixed(2)}`
                    ).join('\n')
                    : '├─ No character bounds available'}

Kashida Points (first line):
${text.__kashidaInfo && text.__kashidaInfo[0] && text.__kashidaInfo[0].length > 0 ?
                    text.__kashidaInfo[0].map((k, i) =>
                        `├─ Point ${i}: charIndex=${k.charIndex}, width=${k.width.toFixed(2)}`
                    ).join('\n')
                    : '├─ No kashida points (kashida: ' + (text.kashida || 'none') + ')'}
`;
            debugInfo.textContent = info;
        }

        function drawBoundingBoxOverlay(text) {
            if (!debugMode || !text) return;

            const bbox = text.getBoundingRect();

            // Draw bounding box rectangle
            const bboxRect = new fabric.Rect({
                left: bbox.left,
                top: bbox.top,
                width: bbox.width,
                height: bbox.height,
                fill: 'rgba(255, 0, 0, 0.1)',
                stroke: 'red',
                strokeWidth: 2,
                strokeDashArray: [5, 5],
                selectable: false,
                evented: false,
                excludeFromExport: true
            });

            // Draw text center point
            const centerPoint = new fabric.Circle({
                left: text.left,
                top: text.top,
                radius: 4,
                fill: 'blue',
                originX: 'center',
                originY: 'center',
                selectable: false,
                evented: false,
                excludeFromExport: true
            });

            // Draw text width visualization
            const textWidthLine = new fabric.Line([
                text.left - text.width / 2,
                text.top,
                text.left + text.width / 2,
                text.top
            ], {
                stroke: 'green',
                strokeWidth: 3,
                selectable: false,
                evented: false,
                excludeFromExport: true
            });

            // Add coordinate labels
            const bboxLabel = new fabric.Text(`BBox: (${bbox.left.toFixed(0)},${bbox.top.toFixed(0)})`, {
                left: bbox.left,
                top: bbox.top - 20,
                fontSize: 12,
                fill: 'red',
                selectable: false,
                evented: false,
                excludeFromExport: true
            });

            const centerLabel = new fabric.Text(`Center: (${text.left.toFixed(0)},${text.top.toFixed(0)})`, {
                left: text.left + 10,
                top: text.top - 10,
                fontSize: 12,
                fill: 'blue',
                selectable: false,
                evented: false,
                excludeFromExport: true
            });

            canvas.add(bboxRect, centerPoint, textWidthLine, bboxLabel, centerLabel);
        }

        function clearDebugOverlays() {
            const objects = canvas.getObjects();
            objects.forEach(obj => {
                if (obj.excludeFromExport) {
                    canvas.remove(obj);
                }
            });
        }

        function showRTLText() {
            clearCanvas();
            currentText = new fabric.Textbox('تجــــربه مرحبا بك في العالم الرقمي', {
                left: 400,
                top: 150,
                width: 300,
                fontFamily: 'Arial',
                fontSize: 24,
                direction: 'rtl',
                textAlign: 'right',
                fill: '#333',
                editable: true,
                selectable: true,
                enableAdvancedLayout: true
            });

            canvas.add(currentText);
            canvas.renderAll();

            setTimeout(() => {
                drawBoundingBoxOverlay(currentText);
                updateDebugInfo(currentText, 'RTL Arabic Text');
            }, 100);
        }

        function showLTRText() {
            clearCanvas();
            currentText = new fabric.Textbox('Hello Digital World', {
                left: 400,
                top: 150,
                width: 300,
                fontFamily: 'Arial',
                fontSize: 24,
                direction: 'ltr',
                textAlign: 'left',
                fill: '#333',
                editable: true,
                selectable: true
            });

            canvas.add(currentText);
            canvas.renderAll();

            setTimeout(() => {
                drawBoundingBoxOverlay(currentText);
                updateDebugInfo(currentText, 'LTR English Text');
            }, 100);
        }

        function showMixedText() {
            clearCanvas();
            currentText = new fabric.Textbox('Hello مرحبا World عالم', {
                left: 400,
                top: 150,
                width: 300,
                fontFamily: 'Arial',
                fontSize: 24,
                direction: 'rtl',
                textAlign: 'center',
                fill: '#333',
                editable: true,
                selectable: true,
                enableAdvancedLayout: true
            });

            canvas.add(currentText);
            canvas.renderAll();

            setTimeout(() => {
                drawBoundingBoxOverlay(currentText);
                updateDebugInfo(currentText, 'Mixed RTL/LTR Text');
            }, 100);
        }

        function showSimpleTest() {
            clearCanvas();

            // Add a simple visible rectangle first to test canvas
            const rect = new fabric.Rect({
                left: 100,
                top: 100,
                width: 50,
                height: 50,
                fill: 'red'
            });
            canvas.add(rect);

            // Test different text approaches
            console.log('Creating basic fabric.Text...');
            const basicText = new fabric.Text('BASIC TEXT', {
                left: 50,
                top: 50,
                fontSize: 30,
                fill: 'red',
                fontFamily: 'Arial'
            });
            canvas.add(basicText);
            console.log('Basic text added:', basicText.getBoundingRect());

            console.log('Creating fabric.IText...');
            currentText = new fabric.IText('ITEXT HERE', {
                left: 50,
                top: 120,
                fontSize: 30,
                fill: 'blue',
                fontFamily: 'Arial',
                editable: true
            });
            canvas.add(currentText);
            console.log('IText added:', currentText.getBoundingRect());

            console.log('Creating RTL text...');
            const rtlText = new fabric.IText('مرحبا', {
                left: 50,
                top: 200,
                fontSize: 30,
                fill: 'green',
                fontFamily: 'Arial',
                direction: 'rtl',
                editable: true
            });
            canvas.add(rtlText);
            console.log('RTL text added:', rtlText.getBoundingRect());

            // Force canvas to render and log all objects
            canvas.renderAll();
            console.log('Canvas objects:', canvas.getObjects().length);
            console.log('Canvas dimensions:', canvas.width, 'x', canvas.height);

            // Try to zoom out to see if text is outside viewport
            canvas.setZoom(0.5);
            canvas.renderAll();

            updateDebugInfo(currentText, 'Simple Test - Check Console');
        }

        function clearCanvas() {
            canvas.clear();
            currentText = null;
            debugInfo.textContent = 'Canvas cleared';
            clickInfo.textContent = 'Click on text to see selection coordinates...';
        }

        function toggleDebugMode() {
            debugMode = !debugMode;
            if (debugMode) {
                if (currentText) {
                    drawBoundingBoxOverlay(currentText);
                    updateDebugInfo(currentText, 'Current Text');
                }
            } else {
                clearDebugOverlays();
                debugInfo.textContent = 'Debug mode disabled';
            }
        }

        // Handle canvas clicks to show selection information
        canvas.on('mouse:down', function (options) {
            if (!options.target || !options.target.type || !options.target.type.includes('text')) return;

            const text = options.target;
            const pointer = canvas.getScenePoint(options.e);
            const selection = text.getSelectionStartFromPointer(options.e);
            const cursorBounds = text._getCursorBoundaries(selection);

            const clickDebugInfo = `
Click Debug Information:
════════════════════════════════════════════════

Mouse Click:
├─ Canvas X: ${pointer.x.toFixed(2)}
├─ Canvas Y: ${pointer.y.toFixed(2)}

Selection Calculation:
├─ Selection Index: ${selection}
├─ Character at index: "${text.text[selection] || 'END'}"

Cursor Boundaries:
├─ Left: ${cursorBounds.left.toFixed(2)}
├─ Top: ${cursorBounds.top.toFixed(2)}
├─ LeftOffset: ${cursorBounds.leftOffset.toFixed(2)}
├─ TopOffset: ${cursorBounds.topOffset.toFixed(2)}
├─ Absolute X: ${(cursorBounds.left + cursorBounds.leftOffset).toFixed(2)}
├─ Absolute Y: ${(cursorBounds.top + cursorBounds.topOffset).toFixed(2)}

Text Direction: ${text.direction}
Text Align: ${text.textAlign}
`;
            clickInfo.textContent = clickDebugInfo;

            // Draw cursor position and character bounds
            clearDebugOverlays();
            drawBoundingBoxOverlay(text);
            drawCharacterBounds(text);

            const cursorX = cursorBounds.left + cursorBounds.leftOffset;
            const cursorY = cursorBounds.top + cursorBounds.topOffset;

            const cursorLine = new fabric.Line([cursorX, cursorY - 10, cursorX, cursorY + 20], {
                stroke: 'orange',
                strokeWidth: 3,
                selectable: false,
                evented: false,
                excludeFromExport: true
            });

            const cursorLabel = new fabric.Text(`Cursor: (${cursorX.toFixed(0)},${cursorY.toFixed(0)})`, {
                left: cursorX + 5,
                top: cursorY - 25,
                fontSize: 12,
                fill: 'orange',
                selectable: false,
                evented: false,
                excludeFromExport: true
            });

            canvas.add(cursorLine, cursorLabel);
        });

        // Alignment helper
        function setAlign(align) {
            if (!currentText) {
                alert('Add a text object first.');
                return;
            }
            currentText.set({ textAlign: align });
            canvas.requestRenderAll();
            clearDebugOverlays();
            drawBoundingBoxOverlay(currentText);
            updateDebugInfo(currentText, `Align: ${align}`);
        }

        // BiDi direction detection
        function getBidiCharDir(char, baseDir) {
            if (/[\u0590-\u05FF\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/.test(char)) {
                return 'rtl';
            }
            if (/[A-Za-z\u00C0-\u024F\u0370-\u03FF\u0400-\u04FF]/.test(char)) {
                return 'ltr';
            }
            return baseDir; // Neutral inherits base
        }

        // Analyze BiDi runs
        function getBiDiRuns(text, baseDir) {
            if (!text) return [];
            const runs = [];
            let current = null;
            for (let i = 0; i < text.length; i++) {
                const dir = getBidiCharDir(text[i], baseDir);
                if (!current || current.direction !== dir) {
                    if (current) runs.push(current);
                    current = { direction: dir, start: i, end: i + 1, text: text[i] };
                } else {
                    current.end = i + 1;
                    current.text += text[i];
                }
            }
            if (current) runs.push(current);
            return runs;
        }

        function drawCharacterBounds(text) {
            if (!debugMode || !text || !text.__charBounds || !text.__charBounds[0]) return;

            console.log('=== Drawing character bounds (BiDi) ===');
            const bbox = text.getBoundingRect();
            const baseY = bbox.top;
            const isRtl = text.direction === 'rtl';
            const chars = text.__charBounds[0];
            const lineLeftOffset = text._getLineLeftOffset(0);
            const lineText = text._textLines[0] ? text._textLines[0].join('') : text.text;

            console.log('Direction:', text.direction, 'Text:', lineText);

            // For LTR, use simple positions
            if (!isRtl) {
                chars.forEach((charBound, i) => {
                    const charText = text._textLines[0]?.[i] || '';
                    const charX = bbox.left + lineLeftOffset + charBound.left;
                    const charWidth = charBound.kernedWidth || charBound.width;
                    drawCharBox(charX, baseY, charWidth, text.fontSize, i, charText);
                });
                return;
            }

            // For RTL: analyze BiDi runs and calculate visual positions
            const runs = getBiDiRuns(lineText, 'rtl');
            console.log('BiDi runs:', runs);

            // Build char info
            const charInfos = chars.map((c, i) => ({
                charIndex: i,
                width: c.kernedWidth || c.width,
                grapheme: text._textLines[0]?.[i] || ''
            }));

            // Group chars by runs
            const runInfos = [];
            for (const run of runs) {
                const runChars = [];
                let totalWidth = 0;
                let strPos = 0;
                for (let i = 0; i < charInfos.length; i++) {
                    const gLen = charInfos[i].grapheme.length || 1;
                    if (strPos >= run.start && strPos < run.end) {
                        runChars.push(charInfos[i]);
                        totalWidth += charInfos[i].width;
                    }
                    strPos += gLen;
                }
                if (runChars.length > 0) {
                    runInfos.push({ direction: run.direction, chars: runChars, totalWidth });
                }
            }

            // Reverse runs for RTL base
            runInfos.reverse();

            // Calculate visual positions
            const visualPositions = new Map();
            let visualX = 0;
            for (const runInfo of runInfos) {
                if (runInfo.direction === 'rtl') {
                    let runX = visualX + runInfo.totalWidth;
                    for (const c of runInfo.chars) {
                        runX -= c.width;
                        visualPositions.set(c.charIndex, { x: runX, width: c.width });
                    }
                } else {
                    let runX = visualX;
                    for (const c of runInfo.chars) {
                        visualPositions.set(c.charIndex, { x: runX, width: c.width });
                        runX += c.width;
                    }
                }
                visualX += runInfo.totalWidth;
            }

            // Draw character boxes
            chars.forEach((charBound, i) => {
                const charText = charInfos[i]?.grapheme || '';
                const pos = visualPositions.get(i);
                if (!pos) return;
                const charX = bbox.left + lineLeftOffset + pos.x;
                drawCharBox(charX, baseY, pos.width, text.fontSize, i, charText);
                console.log(`Char ${i} "${charText}": visualX=${pos.x.toFixed(2)}, canvasX=${charX.toFixed(2)}`);
            });
        }

        function drawCharBox(x, y, width, height, index, charText) {
            const fillColor = index % 2 === 0 ? 'rgba(255, 0, 255, 0.2)' : 'rgba(0, 255, 255, 0.2)';
            const strokeColor = index % 2 === 0 ? 'magenta' : 'cyan';

            const charRect = new fabric.Rect({
                left: x, top: y, width: width, height: height,
                fill: fillColor, stroke: strokeColor, strokeWidth: 1,
                selectable: false, evented: false, excludeFromExport: true
            });

            const charLabel = new fabric.Text(`${index}:"${charText}"`, {
                left: x, top: y - 15, fontSize: 10, fill: 'purple',
                fontFamily: 'Arial', selectable: false, evented: false, excludeFromExport: true
            });

            canvas.add(charRect, charLabel);
        }

        // Update debug info when text properties change
        canvas.on('object:modified', function (options) {
            if (options.target && options.target.type.includes('text')) {
                clearDebugOverlays();
                drawBoundingBoxOverlay(options.target);
                updateDebugInfo(options.target, 'Modified Text');
            }
        });

        // Add STV font test functions
        function showSTVFont() {
            clearCanvas();
            currentText = new fabric.Textbox('هذا نص تجريبي بخط STV العادي للاختبار', {
                left: 400,
                top: 150,
                width: 400,
                fontFamily: 'STV',
                fontSize: 28,
                fontWeight: 'normal',
                direction: 'rtl',
                textAlign: 'right',
                fill: '#333',
                editable: true,
                selectable: true
            });

            canvas.add(currentText);
            canvas.renderAll();

            setTimeout(() => {
                drawBoundingBoxOverlay(currentText);
                updateDebugInfo(currentText, 'STV Regular Font Arabic Text');
            }, 300);
        }

        function showSTVBold() {
            clearCanvas();
            currentText = new fabric.Textbox('هذا نص تجريبي بخط STV الغامق للاختبار', {
                left: 400,
                top: 150,
                width: 400,
                fontFamily: 'STV',
                fontSize: 28,
                fontWeight: 'bold',
                direction: 'rtl',
                textAlign: 'right',
                fill: '#333',
                editable: true,
                selectable: true
            });

            canvas.add(currentText);
            canvas.renderAll();

            setTimeout(() => {
                drawBoundingBoxOverlay(currentText);
                updateDebugInfo(currentText, 'STV Bold Font Arabic Text');
            }, 300);
        }

        function showSTVLight() {
            clearCanvas();
            currentText = new fabric.Textbox('هذا نص تجريبي بخط STV الخفيف للاختبار', {
                left: 400,
                top: 150,
                width: 400,
                fontFamily: 'STV',
                fontSize: 28,
                fontWeight: 300,
                direction: 'rtl',
                textAlign: 'right',
                fill: '#333',
                editable: true,
                selectable: true
            });

            canvas.add(currentText);
            canvas.renderAll();

            setTimeout(() => {
                drawBoundingBoxOverlay(currentText);
                updateDebugInfo(currentText, 'STV Light Font Arabic Text');
            }, 300);
        }

        // Export JSON functionality
        function exportJSON() {
            const json = JSON.stringify(canvas.toJSON(['fontFamily', 'direction', 'textAlign']));
            console.log('Canvas JSON:', json);

            // Create download link
            const link = document.createElement('a');
            link.download = `rtl-debug-canvas-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
            link.href = 'data:text/json;charset=utf-8,' + encodeURIComponent(json);

            // Trigger download
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            debugInfo.textContent = 'Canvas exported as JSON file';
            return json;
        }

        // Import JSON functionality
        function loadJSONFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                importJSON(e.target.result);
            };
            reader.readAsText(file);
        }

        function importJSON(jsonString) {
            try {
                console.log('Loading JSON into canvas...');
                const parsed = JSON.parse(jsonString);

                canvas.loadFromJSON(parsed, function () {
                    canvas.requestRenderAll();
                    console.log('JSON loaded successfully');

                    // Find the first text object
                    const objects = canvas.getObjects();
                    currentText = objects.find(obj => obj.type === 'textbox' || obj.type === 'text' || obj.type === 'i-text');

                    if (currentText) {
                        console.log('Found text object:', currentText);
                        setTimeout(() => {
                            if (debugMode) {
                                drawBoundingBoxOverlay(currentText);
                            }
                            updateDebugInfo(currentText, 'Loaded from JSON');
                        }, 300); // Extra time for font loading
                    }

                    debugInfo.textContent = `JSON loaded successfully. Found ${objects.length} objects.`;
                });
            } catch (error) {
                console.error('Error loading JSON:', error);
                debugInfo.textContent = 'Error loading JSON: ' + error.message;
            }
        }

        // Kashida test function
        function showKashidaTest(kashidaLevel) {
            clearCanvas();

            // Create multiple lines of Arabic text to test justify with kashida
            const arabicText = 'هذا نص تجريبي طويل لاختبار خاصية الكاشيدة في المحاذاة المتساوية للنصوص العربية وهو يحتوي على عدة كلمات';

            currentText = new fabric.Textbox(arabicText, {
                left: 400,
                top: 150,
                width: 350,
                fontFamily: 'Arial',
                fontSize: 24,
                direction: 'rtl',
                textAlign: 'justify',
                fill: '#333',
                editable: true,
                selectable: true,
                kashida: kashidaLevel,
                enableAdvancedLayout: true
            });

            canvas.add(currentText);
            canvas.renderAll();

            setTimeout(() => {
                drawBoundingBoxOverlay(currentText);
                updateDebugInfo(currentText, `Kashida: ${kashidaLevel}`);

                // Show kashida info in debug
                if (currentText.__kashidaInfo) {
                    console.log('Kashida Info:', currentText.__kashidaInfo);
                }
            }, 100);
        }

        // Set kashida on current text
        function setKashida(level) {
            if (!currentText) {
                alert('Add a text object first.');
                return;
            }

            // Kashida only works with justify alignment
            if (!currentText.textAlign.includes('justify')) {
                currentText.set({ textAlign: 'justify' });
                console.log('Changed textAlign to justify (required for kashida)');
            }

            currentText.set({ kashida: level });

            // Force clear cache and reset dimension state to force recalculation
            currentText._clearCache();
            currentText._lastDimensionState = null; // Force initDimensions to recalculate
            currentText.initDimensions();
            currentText.setCoords();

            canvas.requestRenderAll();
            clearDebugOverlays();
            drawBoundingBoxOverlay(currentText);
            updateDebugInfo(currentText, `Kashida: ${level}`);

            console.log('Kashida set to:', level);
            console.log('Kashida Info:', currentText.__kashidaInfo);
        }

        // Initialize with RTL text
        showRTLText();
    </script>
</body>

</html>