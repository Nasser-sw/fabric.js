<!DOCTYPE html>
<html>
<head>
    <title>Fabric.js RTL HTML Editor Test</title>
    <style>
        body {
            margin: 20px;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
        }
        
        .container {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .test-section {
            margin-bottom: 30px;
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 5px;
        }
        
        .test-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }
        
        .canvas-container {
            position: relative; /* Required for editor positioning */
            margin: 10px 0;
            border: 1px solid #ccc;
        }
        
        .log-output {
            background-color: #f8f8f8;
            border: 1px solid #ddd;
            padding: 10px;
            margin-top: 10px;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .instructions {
            background-color: #e8f4fd;
            border-left: 4px solid #2196F3;
            padding: 10px;
            margin-bottom: 15px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Fabric.js RTL HTML Editor Implementation</h1>
        
        <div class="instructions">
            <strong>RTL Text HTML Editor Test Instructions:</strong>
            <ol>
                <li><strong>Rotate an object slightly</strong> using its corner handle.</li>
                <li><strong>Double-click the rotated text</strong> to enter HTML editor mode.</li>
                <li>Observe the transition. It should be **perfectly seamless with zero jump**.</li>
                <li>While editing, scroll the page or resize the window. The editor will "stick" to the rotated object's position.</li>
            </ol>
            <p><strong>Expected Result:</strong> A robust, seamless transition for objects at any position, scale, or rotation.</p>
        </div>
        
        <div class="test-section">
            <div class="test-title">1. Arabic RTL Text - Cursor & Selection Test</div>
            <div class="canvas-container">
                <canvas id="rtl-canvas" width="600" height="150"></canvas>
            </div>
            <div id="rtl-log" class="log-output">RTL selection logs will appear here...</div>
        </div>
        
        <div class="test-section">
            <div class="test-title">2. English LTR Text (Reference)</div>
            <div class="canvas-container">
                <canvas id="ltr-canvas" width="600" height="150"></canvas>
            </div>
            <div id="ltr-log" class="log-output">LTR selection logs will appear here...</div>
        </div>
        
        <div class="test-section">
            <div class="test-title">3. Mixed BiDi Text (Complex Case)</div>
            <div class="canvas-container">
                <canvas id="bidi-canvas" width="600" height="150"></canvas>
            </div>
            <div id="bidi-log" class="log-output">BiDi selection logs will appear here...</div>
        </div>
        
        <div class="test-section">
            <div class="test-title">4. Multi-line RTL Text (Textbox with wrapping)</div>
            <div class="canvas-container">
                <canvas id="multiline-canvas" width="600" height="200"></canvas>
            </div>
            <div id="multiline-log" class="log-output">Multi-line RTL logs will appear here...</div>
        </div>
        
        <div class="test-section">
            <div class="test-title">5. RTL Text with Different Alignments</div>
            <div class="canvas-container">
                <canvas id="alignment-canvas" width="600" height="300"></canvas>
            </div>
            <div id="alignment-log" class="log-output">Alignment test logs will appear here...</div>
        </div>
    </div>

    <!-- Load Fabric.js from dist -->
    <script src="../../dist/index.js"></script>
    
    <script>
        // --- SEAMLESS HTML EDITOR SYSTEM (HERO VERSION) ---
        class FabricHTMLEditor {
            constructor() {
                this.textarea = null;
                this.activeObject = null;
                this.canvas = null;
                this.isActive = false;
                this.boundReposition = this.repositionEditor.bind(this);
                this.initEditor();
            }
            
            initEditor() {
                this.textarea = document.createElement('textarea');
                this.textarea.style.cssText = `
                    position: absolute;
                    display: none;
                    resize: none;
                    overflow: auto;
                    padding: 0;
                    margin: 0;
                    border: none;
                    background: transparent;
                    box-sizing: border-box;
                    outline: none;
                    white-space: pre-wrap;
                    word-wrap: break-word;
                    z-index: 1000;
                    min-height: inherit;
                `;
                document.body.appendChild(this.textarea);
                this.textarea.addEventListener('blur', () => this.exitEditMode());
                this.textarea.addEventListener('input', () => this.autoResizeTextarea());
            }
            
            startEditMode(fabricObject, canvas) {
                if (this.isActive) return;
                
                this.activeObject = fabricObject;
                this.canvas = canvas;
                this.isActive = true;
                
                // Synchronize and position the editor
                this.repositionEditor();
                this.synchronizeStyles();
                this.synchronizeTransforms();
                
                this.executeSwap();
                
                window.addEventListener('scroll', this.boundReposition, true);
                window.addEventListener('resize', this.boundReposition);
            }

            repositionEditor() {
                if (!this.isActive) return;
                const geometry = this.calculateGeometry();
                this.textarea.style.left = geometry.left + 'px';
                this.textarea.style.top = geometry.top + 'px';
                this.textarea.style.width = geometry.width + 'px';
                this.textarea.style.height = geometry.height + 'px';
            }
            
            autoResizeTextarea() {
                if (!this.isActive) return;
                
                // Reset height to auto to get the natural content height
                this.textarea.style.height = 'auto';
                // Set height to scrollHeight to fit all content
                this.textarea.style.height = this.textarea.scrollHeight + 'px';
                
                console.log(`HTML Editor: Auto-resized to ${this.textarea.scrollHeight}px height`);
            }
            
            // HERO'S FIX 1/3: New geometry calculation using transformed coordinates
            calculateGeometry() {
                const obj = this.activeObject;
                const canvas = this.canvas;
                const canvasEl = canvas.getElement();
                const canvasRect = canvasEl.getBoundingClientRect();
                const zoom = canvas.getZoom();

                // Get the object's absolute corner coordinates (aCoords), which account for rotation.
                // This is the key to perfect alignment.
                const aCoords = obj.aCoords;
                
                const scrollX = window.scrollX || window.pageXOffset;
                const scrollY = window.scrollY || window.pageYOffset;

                // Position the editor at the object's true top-left corner
                const left = canvasRect.left + scrollX + aCoords.tl.x;
                const top = canvasRect.top + scrollY + aCoords.tl.y;

                // Set the editor's size to the object's un-rotated, scaled dimensions
                const width = obj.getScaledWidth() * zoom;
                const height = obj.getScaledHeight() * zoom;

                log(obj.logId, `Editor Reposition (Rotated): left=${left.toFixed(1)}, top=${top.toFixed(1)}`);
                
                return { left, top, width, height, zoom };
            }
            
            synchronizeStyles() {
                const obj = this.activeObject;
                const zoom = this.canvas.getZoom();
                const textarea = this.textarea;
                
                textarea.style.fontFamily = obj.fontFamily || 'Arial';
                textarea.style.fontSize = obj.fontSize + 'px';  // Don't multiply by zoom - container size already accounts for it
                textarea.style.fontWeight = obj.fontWeight || 'normal';
                textarea.style.fontStyle = obj.fontStyle || 'normal';
                
                // Ensure consistent font rendering between Fabric and CSS
                textarea.style.fontVariant = 'normal';
                textarea.style.fontStretch = 'normal';
                textarea.style.textRendering = 'auto';
                textarea.style.fontKerning = 'auto';
                textarea.style.color = obj.fill || '#000000';
                textarea.style.textAlign = obj.textAlign || 'left';
                // Debug line height values
                console.log(`HTML Editor: Fabric lineHeight = ${obj.lineHeight}, fontSize = ${obj.fontSize}`);
                
                // Fabric.js uses lineHeight as a multiplier of fontSize (usually 1.16 default)
                // We need to convert this to match exactly how Fabric renders lines
                const fabricLineHeight = obj.lineHeight || 1.16;
                const actualLineHeight = fabricLineHeight * obj.fontSize;
                
                // Set as pixel value to match Fabric's calculation exactly
                textarea.style.lineHeight = actualLineHeight + 'px';
                
                textarea.style.letterSpacing = (obj.charSpacing || 0) / 1000 + 'em';
                textarea.style.direction = obj.direction || 'ltr';
                
                console.log(`HTML Editor: Set CSS lineHeight = ${actualLineHeight}px (${fabricLineHeight} × ${obj.fontSize})`);
                
                let textDecoration = 'none';
                if (obj.underline) textDecoration += ' underline';
                if (obj.overline) textDecoration += ' overline';  
                if (obj.linethrough) textDecoration += ' line-through';
                textarea.style.textDecoration = textDecoration.trim();
                
                textarea.value = obj.text || '';
            }

            // HERO'S FIX 2/3: Update transform logic for the new positioning method
            synchronizeTransforms() {
                const obj = this.activeObject;
                const textarea = this.textarea;

                // We only need to apply rotation, as position and scale are handled directly.
                textarea.style.transform = `rotate(${obj.angle || 0}deg)`;
                
                // HERO'S FIX 3/3: The transform origin MUST be top-left (0 0)
                // because we positioned the textarea using the object's top-left corner (aCoords.tl).
                textarea.style.transformOrigin = '0 0';
            }

            executeSwap() {
                const obj = this.activeObject;
                log(obj.logId, 'HTML Editor: Executing swap - textarea visible, Fabric object hidden.');
                
                this.textarea.style.display = 'block';
                obj.visible = false;
                this.canvas.requestRenderAll();
                
                setTimeout(() => {
                    this.textarea.focus();
                    this.textarea.select();
                    this.autoResizeTextarea();  // Ensure proper initial sizing
                }, 10);
            }
            
            exitEditMode() {
                if (!this.isActive) return;
                
                log(this.activeObject.logId, 'HTML Editor: Exiting edit mode - reverse swap.');
                
                window.removeEventListener('scroll', this.boundReposition, true);
                window.removeEventListener('resize', this.boundReposition);

                this.activeObject.set('text', this.textarea.value);
                this.activeObject.set('visible', true);
                this.canvas.requestRenderAll();
                this.textarea.style.display = 'none';
                
                this.isActive = false;
                this.activeObject = null;
                this.canvas = null;
            }
        }
        
        // --- TEST SETUP ---
        
        const htmlEditor = new FabricHTMLEditor();
        
        const tests = [
            { id: 'rtl-canvas', logId: 'rtl-log', text: 'مرحبا بكم في Fabric.js - هذا نص عربي للاختبار', direction: 'rtl', textAlign: 'right', width: 500 },
            { id: 'ltr-canvas', logId: 'ltr-log', text: 'Welcome to Fabric.js - This is English text for testing', direction: 'ltr', textAlign: 'left', width: 500 },
            { id: 'bidi-canvas', logId: 'bidi-log', text: 'Fabric.js مرحبا welcome نص مختلط mixed text', direction: 'ltr', textAlign: 'left', width: 500 },
            { id: 'multiline-canvas', logId: 'multiline-log', text: 'هذا نص طويل باللغة العربية يجب أن يلتف إلى عدة أسطر لاختبار الاختيار متعدد الأسطر في النصوص من اليمين إلى اليسار', direction: 'rtl', textAlign: 'right', width: 400 },
            { id: 'alignment-canvas', logId: 'alignment-log', text: 'اختبار محاذاة النص', direction: 'rtl', textAlign: 'center', width: 500, isAlignment: true }
        ];
        
        function log(testId, message) {
            const logElement = document.getElementById(testId);
            const timestamp = new Date().toLocaleTimeString();
            logElement.innerHTML += `[${timestamp}] ${message}<br>`;
            logElement.scrollTop = logElement.scrollHeight;
            console.log(`[${testId}] ${message}`);
        }
        
        tests.forEach(test => {
            const canvas = new fabric.Canvas(test.id, { backgroundColor: '#f9f9f9', selection: true });
            
            canvas.on('text:editing:entered', (e) => e.target && e.target.exitEditing());

            const createTextbox = (text, options) => {
                const textbox = new fabric.Textbox(text, options);
                textbox.logId = test.logId;
                
                textbox.on('mousedblclick', function() {
                    log(test.logId, `Double-click detected - starting HTML editor mode.`);
                    htmlEditor.startEditMode(this, canvas);
                });
                return textbox;
            };

            if (test.isAlignment) {
                const alignments = ['left', 'center', 'right'];
                alignments.forEach((align, index) => {
                    const textbox = createTextbox(test.text + ' - ' + align, {
                        left: 50, top: 30 + (index * 80), width: test.width, fontSize: 20,
                        fontFamily: 'Arial', direction: test.direction, textAlign: align,
                    });
                    canvas.add(textbox);
                });
                log(test.logId, `Initialized alignment test with alignments: ${alignments.join(', ')}.`);
            } else {
                const textbox = createTextbox(test.text, {
                    left: 50, top: 50, width: test.width, fontSize: 24,
                    fontFamily: 'Arial', direction: test.direction, textAlign: test.textAlign,
                });
                canvas.add(textbox);
                log(test.logId, `Initialized: text="${test.text}", direction="${test.direction}", align="${test.textAlign}".`);
            }
        });
        
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'l') {
                e.preventDefault();
                tests.forEach(test => {
                    document.getElementById(test.logId).innerHTML = 'Logs cleared...<br>';
                });
            }
        });
        
        console.log('RTL HTML Editor Test Page loaded. Double-click text to edit. Press Ctrl+L to clear logs.');
    </script>
</body>
</html>